'use strict';

var fs = require('fs');
var extend = require('extend-shallow');
var parse = require('./lib/parse');
var defaults = require('./lib/defaults');
var stringify = require('./lib/stringify');
var excerpt = require('./lib/excerpt');
var engines = require('./lib/engines');
var toFile = require('./lib/to-file');
var utils = require('./lib/utils');
var cache = {};

/**
 * Takes a string or object with `content` property, extracts
 * and parses front-matter from the string, then returns an object
 * with `data`, `content` and other [useful properties](#returned-object).
 *
 * ```js
 * var matter = require('gray-matter');
 * console.log(matter('---\ntitle: Home\n---\nOther stuff'));
 * //=> { data: { title: 'Home'}, content: 'Other stuff' }
 * ```
 * @param {Object|String} `input` String, or object with `content` string
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

function matter(input, options) {
  var file = {data: {}, content: input, excerpt: '', orig: input};
  if (input === '') return file;

  file = toFile(input);
  var cached = cache[file.content];

  if (!options) {
    if (cached) {
      file = extend({}, cached);
      file.orig = cached.orig;
      return file;
    }
    cache[file.content] = file;
  }

  return parseMatter(file, options);
}

function parseMatter(file, options) {
  var opts = defaults(options);
  var open = opts.delimiters[0];
  var close = '\n' + opts.delimiters[1];
  var str = file.content;

  if (opts.language) {
    file.language = opts.language;
  }

  // get the length of the opening delimiter
  var openLen = open.length;
  if (!utils.startsWith(str, open, openLen)) {
    excerpt(file, opts);
    return file;
  }

  // if the next character after the opening delimiter is
  // a character from the delimiter, then it's not a front-
  // matter delimiter
  if (str.charAt(openLen) === open.slice(-1)) {
    return file;
  }

  // strip the opening delimiter
  str = str.slice(openLen);
  var len = str.length;

  // use the language defined after first delimiter, if it exists
  var language = matter.language(str, opts);
  if (language.name) {
    file.language = language.name;
    str = str.slice(language.raw.length);
  }

  // get the index of the closing delimiter
  var closeIndex = str.indexOf(close);
  if (closeIndex === -1) {
    closeIndex = len;
  }

  // get the raw front-matter block
  file.matter = str.slice(0, closeIndex);

  // create file.data by parsing the raw file.matter block
  file.data = parse(file.language, file.matter, opts);

  // update file.content
  if (closeIndex === len) {
    file.content = '';
  } else {
    file.content = str.slice(closeIndex + close.length);
    if (file.content[0] === '\r') {
      file.content = file.content.slice(1);
    }
    if (file.content[0] === '\n') {
      file.content = file.content.slice(1);
    }
  }

  excerpt(file, opts);

  if (opts.sections === true) {
    matter.sections(file, opts);
  }
  return file;
}

/**
 * Expose engines
 */

matter.engines = engines;

/**
 * Parse matter-sections from a file (experimental)
 *
 * @param {Object} `file`
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

matter.sections = function(file, options) {
  var idx = file.content.indexOf('----');

  if (idx === -1 || (idx !== 0 && file.content[idx - 1] !== '\n')) {
    if (file.sections.length) {
      file.sections[file.sections.length - 1].content = file.content;
      file.content = file.text.join('\n');
      delete file.text;
    }
    return file;
  }

  var orig = file.content;
  file.sections = file.sections || [];
  file.text = file.text || [];

  var rest = file.content.slice(idx + 5);
  var content = file.content.slice(0, idx);
  if (file.sections.length === 0) {
    file.text.push(content);
  } else {
    file.sections[file.sections.length - 1].content = content;
  }

  var end = rest.indexOf('\n----');
  if (end === -1) {
    file.content = orig;
    return file;
  }

  file.sections.push({data: rest.slice(0, end)});
  file.content = rest.slice(end + 5);
  return matter.sections(file, options);
};

/**
 * Stringify an object to YAML or the specified language, and
 * append it to the given string. By default, only YAML and JSON
 * can be stringified. See the [engines](#engines) section to learn
 * how to stringify other languages.
 *
 * ```js
 * console.log(matter.stringify('foo bar baz', {title: 'Home'}));
 * // results in:
 * // ---
 * // title: Home
 * // ---
 * // foo bar baz
 * ```
 * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.
 * @param {Object} `data` Front matter to stringify.
 * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].
 * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.
 * @api public
 */

matter.stringify = function(file, data, options) {
  if (typeof file === 'string') {
    file = matter(file, options);
  }
  return stringify(file, data, options);
};

/**
 * Synchronously read a file from the file system and parse
 * front matter. Returns the same object as the [main function](#matter).
 *
 * ```js
 * var file = matter.read('./content/blog-post.md');
 * ```
 * @param {String} `filepath` file path of the file to read.
 * @param {Object} `options` [Options](#options) to pass to gray-matter.
 * @return {Object} Returns [an object](#returned-object) with `data` and `content`
 * @api public
 */

matter.read = function(filepath, options) {
  var str = fs.readFileSync(filepath, 'utf8');
  var file = matter(str, options);
  file.path = filepath;
  return file;
};

/**
 * Returns true if the given `string` has front matter.
 * @param  {String} `string`
 * @param  {Object} `options`
 * @return {Boolean} True if front matter exists.
 * @api public
 */

matter.test = function(str, options) {
  var opts = defaults(options);
  return utils.startsWith(str, opts.delimiters[0]);
};

/**
 * Detect the language to use, if one is defined after the
 * first front-matter delimiter.
 * @param  {String} `string`
 * @param  {Object} `options`
 * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed
 */

matter.language = function(str, options) {
  var opts = defaults(options);
  var open = opts.delimiters[0];

  if (matter.test(str)) {
    str = str.slice(open.length);
  }

  var language = str.slice(0, str.search(/\r?\n/));
  return {
    raw: language,
    name: language ? language.trim() : ''
  };
};

/**
 * Expose `matter`
 */

module.exports = matter;
